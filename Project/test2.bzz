
# Put your global variables here

# This function is executed every time you press the 'execute' button
function init() {
   # put your code here
	s = swarm.create(1)
  queue = {}
  visited = {}
  adj = {}
  found = 0
	init_obj = {.x = 0.3, .y = -1.0}
	goal = {.x = -1.0, .y = -0.5}
	leader = {.x = 1000.0, .y = 1000.0}
	state = 0
	posx = pose.position.x
	posy = pose.position.y
	set_leds(255,0,0) # red
	m = 10
	vl = 12.0
	vr = 12.0
	togo_x = goal.x - posx
  togo_y = goal.y - posy
	goal_t = math.atan(togo_y,togo_x)
	togo_t = (pose.orientation.yaw - math.atan(togo_y,togo_x))
	if (togo_t > 3.1416) {
		togo_t = togo_t - 6.2832}
	else if (togo_t < -3.1416) {
		togo_t = togo_t + 6.2832}
	flag = 0
	priority = 1
	r_c = 0
	recruit_dist = 0.6
	recruited = {.0 = 0,.1 = 0,.2 = 0, .3 = 0}
	set_wheels(vl,vr)
}

# This function is executed at each time step
# It must contain the logic of your controller
function step() {
   # put your code here
	neighbors.broadcast("mypose0",pose.position)
	if (state > 0) {
		neighbors.broadcast("mypose1",pose.position)
		neighbors.broadcast("recruited",1)}
	if (state == 0) {
		ob_avoid()
		neighbors.listen("recruit_id",
			function(vid,value,rid) {
				log("Checking if ",value," is recruited")
				if (value == id) {
					state = 2
					log("no.",id,"enters state 2")
					set_leds(0,204,0) #green
					s.join()
					recruited[id] = 1
					log("no.", id," following no.",leader_id)}	
			})
		distx = init_obj.x - posx
		disty = init_obj.y - posy
		dist_mag = math.sqrt((distx^2 + disty^2))
		if ((dist_mag < 0.35) and (state == 0)) {
			state = 1
			log("no.",id,"enters state 1")
			set_leds(0,0,255) # blue
			s.join()
			recruited[id] = 1
			make_space = 0
			neighbors.broadcast("mypose1",pose.position)
		}
	}

	if (state == 1) {
		neighbors.broadcast("mypose1",pose.position)
		if (make_space < 5) {
			set_wheels(-6.0,-6.0)
			make_space = make_space + 1}
		else {
			ob_avoid()}
	}
		
	if (state == 2) {
		neighbors.listen("mypose1",
			function(vid,value,rid) {
				log(id," got pose of ",rid)
				leader.x = value.x
				leader.y = value.y
				recruited[rid] = 1
			}
		)
		r2r_x = leader.x - posx 
		r2r_y = leader.y - posy
		r2r_mag = math.sqrt(r2r_x^2 + r2r_y^2)
		r2r_t = (pose.orientation.yaw - math.atan(r2r_y,r2r_x))
		if (r2r_t > 3.1416) {
			r2r_t = r2r_t - 6.2832}
		else if (r2r_t < -3.1416) {
			r2r_t = r2r_t + 6.2832}
		follow(r2r_x,r2r_y,r2r_t,r2r_mag)
	}
	posx = pose.position.x
	posy = pose.position.y
	r_count = 0
	neighbors.listen("recruited", 
		function(vid_r,value_r,rid_r) {
			recruited[rid_r] = 1}
	)
	foreach(recruited,function(key,value) {
		r_count = r_count + value})
	if (r_count == 4) {
		log("recruitment complete!")
		set_wheels(0.0,0.0)
		state = 3
		set_leds(255,255,0) #yellow
	}
		
}

function follow(tg_x,tg_y,tg_t,tg_mag) {
	tg_t_thresh = 0.05
	if (tg_t < tg_t_thresh*-1.0) {
		set_wheels(10.0,15.0)}
	else if (tg_t > tg_t_thresh) {
		set_wheels(15.0,10.0)}
	else if (tg_mag > 0.2) {
		set_wheels(15.0,15.0)}
	else {
		set_wheels(0.0,0.0)}
	tg_t = (pose.orientation.yaw - math.atan(tg_y,tg_x))
	
}	

function random_walk() {
  dirx = 12.0
 	diry = math.rng.uniform(7.0,17.0)
	set_wheels(dirx,diry)
}


function ob_avoid() {
	dvl = 4.0
	dvr = 4.0
	flag = 0
	foreach(proximity, function(key, value) {
		if (value.value > 0) {
			flag = flag + 1
			priority = 2
			if (value.angle == 0) {
				vr = -6.0
				vl = 6.0
				set_wheels(vl,vr)
			}
			else if ((value.angle > 3) and (value.angle < 3.15)) {
				vl = 8.0
				vr = 8.0
			}
			else {
				vl = vl + dvl*math.sin(value.angle)
				vr = vr - 1.1*dvr*math.sin(value.angle)
				set_wheels(vl,vr)}
		}
	})
	if ((flag == 0) and (state == 0)) {
		vl = 10.0
		vr = 10.0
		if (not(r_c % 5 == 0)) {
			random_walk()
		}
		r_c = r_c + 1
	}
	else if ((flag < 3) and (state == 1)) {
		reach = 10000.0 #dist from leader to others set to high value
		recruit_check = 0
		neighbors.foreach(
			function(rid,data) {
				#keep track of recruitments

				#get distance of closest neighbor
				if ((data.distance < reach) and (recruited[rid] == 0)){
					reach = data.distance
					reach_id = rid
					recruit_check = 1}})
		log("no.",id, " recruiting no.",reach_id)
		neighbors.listen("mypose0",
			function(myvid,myvalue,myrid) {
				temp_id = myrid
				if ((myrid == reach_id) and (recruit_check == 1)) {
					reach_x = myvalue.x
					reach_y = myvalue.y
					d_x = reach_x - posx 
					d_y = reach_y - posy
					d_mag = math.sqrt(d_x^2 + d_y^2)
					d_t = (pose.orientation.yaw - math.atan(d_y,d_x))
					if (d_t > 3.1416) {
						d_t = d_t - 6.2832}
					else if (d_t < -3.1416) {
						d_t = d_t + 6.2832}
					follow(d_x,d_y,d_t,d_mag)
					if (d_mag < recruit_dist) {
						recruited[myrid] = 1
						s.join()
						log("no.",reach_id," recruited")
						neighbors.broadcast("recruit_id",reach_id)
					}
				}
				else {
					random_walk()}
			})
	}
	else if (flag > 3) {
		vl = 7.0
		vr = -6.0
		set_wheels(vl,vr)
	}

}

# This function is executed every time you press the 'reset'
# button in the GUI. It is supposed to restore the state
# of the controller to whatever it was right after init() was
# called. The state of sensors and actuators is reset
# automatically by ARGoS.
function reset() {
   # put your code here
}



# This function is executed only once, when the robot is removed
# from the simulation
function destroy() {
   # put your code here
}
